Modules

include - all those methods will be added to all instances
extend - class level methods

modules used for namespacing

class Account < ActiveRecord::Base
	has_many :users, default: true
end

same as
class Account < ActiveRecord::Base
	Account.has_many(:users, {defult: true})
end


block not object - store blocks wwithin procs

lambdas like procs - but counts number of arguments that ae passed through
difference in return behaviour


instance_eval - can run code in the block that's passed through to it in the context of the class that it's in


MVC = ARCHITECTURAL design pattern (diff to design pattern)

DESIGN PATTERNS
Patterns of Enterprise Application Architecture (book)
Design Patterns (Gang of Four book) Elements of 
Design Patterns in Ruby


1. 	Active Record - actually design pattern name that Rails ActiveRecord is built with
2. 	Front Controller

		RACK - at it's simplest is a specification for how the web server communicates with your application (/framework). If a webserver is rack compliant - it can host rails
		A rack application must respond to 'call' method - takes environment hash and outputs an array with STATUS, HEADER and BODY - browser converts this into a HTTP response


		config.ru - tells the web server how to boot your app (load/define app run). ru = rack up  but just ruby code. name is convention (just like index.html - config.ru is looked for by web server)

		Middleware. Like an app - can only have one app running at one time but can have multiple middlewares running on top of one another (kind of like before and after filers - add behaviour on top of app, either before or after). Reusable functionality that you can put on top of any application. Can easily comment out the "use <Middleware>" call to stop that functionality without affecting the app. 
		Can chain middleware, e.g. run Logger.new(Caching.new(App.new)), calls the call method from Logger then Caching then App - each call references the next
		
